import java.util.PriorityQueue;			// used in generating Huffman encoding (want to order symbols in decreasing prob)
import java.util.Stack;					// used in generating Huffman encoding (traverse completed tree to build codewords) 


/**
 * Huffman encoding for a RV distribution, generated by <code>generateeHufman</code>.
 *
 * For efficient encoding and decoding the codewords are stored twice. For encoding: The array <code>codewords</code> is
 * a simple lookup using the character ACSII code as index. For decoding: The binary tree <code>tree</code> is used to
 */
public class Huffman {

    Node			tree;		// root node in Huffman tree (used for decoding)
    String[]		codewords;	// array of codewords (used for encoding)
    Distribution	rv;		// distribution used to generate Huffman codewords

    public Huffman(Distribution rv) {
        tree = null;
        codewords = new String[Distribution.RANGE];
        this.rv = rv;
    }


    /**
     * Generate Huffman tree and codewords for given probability distribution.
     *
     * The input probability distribution may have entries with zero probabilities. The resulting codewords for these
     * symbols is null.
     *
     * @paramarray of probability (could contain zero values)
     *
     * @return array of codewords (null for symbol with zero probability)
     */
    public static Huffman generate(Distribution rv) {

        Huffman result = new Huffman(rv);

        // populate priority queue by adding entries with non-zero probability
        // TODO

        // Repeatedly merge smallest probability symbols until only one entry
        // TODO

        // store top of queue as root node in Huffman tree
        // TODO

        // Traverse tree to build codewords
        //
        // use stack of Node, starting with Huffman tree root, visiting children, adding nodes to tree when found
        // at each node update codewords and if at a leaf then set corresponding entry in <code>codewords</code> array
        // TODO

        return result;
    }

    /**
     * Calculate the average codeword length, L(C), in a Huffman encoding.
     *
     * @return L(C)
     */
    public double codewordLength() {

        double sum = 0;
        // TODO
        return sum;

    }

    /**
     * Encode a message using Huffamn encoding.
     *
     * @param source
     *            Original message to be encoded
     *
     * @return Message encoded using Huffman encoding.
     */
    public String encode(String source) {

        StringBuilder result = new StringBuilder();

        // source message is encoded symbol by symbol . . .
        // for each character in source lookup corresponding codeword and append to result.
        // TODO

        return result.toString();
    }

    /**
     * Decode a message using Huffamn encoding.
     *
     * @param encoded
     *            Encoded message to be decoded
     *
     * @return Message decoded using Huffman encoding.
     */
    public String decode(String encoded) {

        StringBuilder result = new StringBuilder();

        // decoding starts at root of Huffman tree
        // TODO

        // We decode the encoded message bit by bit . . .
        // for each bit if it is 0 then move down left child node, if 1 then move down right child node
        // if at a leaf node then we have decoding a symbol, append symbol to result and jump to root of tree
        // TODO

        return result.toString();
    }

}


/**
 * Node used to construct the Huffman code tree.
 *
 * On creation the node just stores the ASCII value of the character and its probability. On completion of the Huffman
 * tree the leaf nodes will store the codeword.
 */
class Node implements Comparable<Node> {
    int		ord;				// ASCII value of character/symbol
    double	p;					// probability
    String	codeword	= "";	// huffman codeword
    Node	left;
    Node	right;

    Node(int id, double p, Node left, Node right) {
        this.ord = id;
        this.p = p;
        this.left = left;
        this.right = right;
    }

    /**
     * This method allows the use of a PriorityQueue to keep the nodes sorted in non-decreasing probability.
     */
    @Override
    public int compareTo(Node other) {

        return (int) Math.signum(this.p - other.p);
    }

    /**
     * Tests if node contains any child nodes.
     *
     * In the Huffman tree each symbol is contained in a single leaf node - important for decoding.
     *
     * @return true if node does not contain child nodes.
     */
    public boolean isLeaf() {
        return (left == null && right == null);
    }


    /**
     * Used for DEBUG output
     */
    public String toString() {
        return String.format("{id:%d, c:%s, p:%f, l:%s, r:%s}", ord, codeword, p, left, right);
    }

}